//! Plan mode: structured multi-step execution plans.
//!
//! When plan mode is enabled, the agent generates a structured plan from
//! plain English input, lets the user review/edit/approve it, and then
//! executes the approved plan step-by-step with progress tracking.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::types::RiskLevel;

/// Status of the overall execution plan.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum PlanStatus {
    /// Plan is being generated by the LLM.
    Generating,
    /// Plan is ready for user review.
    PendingReview,
    /// User is editing the plan.
    Editing,
    /// Plan is being executed step-by-step.
    Executing,
    /// All steps completed successfully.
    Completed,
    /// One or more steps failed.
    Failed,
    /// User cancelled the plan.
    Cancelled,
}

impl std::fmt::Display for PlanStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PlanStatus::Generating => write!(f, "generating"),
            PlanStatus::PendingReview => write!(f, "pending review"),
            PlanStatus::Editing => write!(f, "editing"),
            PlanStatus::Executing => write!(f, "executing"),
            PlanStatus::Completed => write!(f, "completed"),
            PlanStatus::Failed => write!(f, "failed"),
            PlanStatus::Cancelled => write!(f, "cancelled"),
        }
    }
}

/// Status of an individual plan step.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum StepStatus {
    #[default]
    Pending,
    InProgress,
    Completed,
    Failed,
    Skipped,
}

impl std::fmt::Display for StepStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            StepStatus::Pending => write!(f, "pending"),
            StepStatus::InProgress => write!(f, "in progress"),
            StepStatus::Completed => write!(f, "completed"),
            StepStatus::Failed => write!(f, "failed"),
            StepStatus::Skipped => write!(f, "skipped"),
        }
    }
}

/// A single step in an execution plan.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlanStep {
    /// Step index (0-based).
    pub index: usize,
    /// Human-readable description of what this step does.
    pub description: String,
    /// Tool to invoke, if any.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tool: Option<String>,
    /// Arguments for the tool, if known ahead of time.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tool_args: Option<serde_json::Value>,
    /// Indices of steps that must complete before this one.
    #[serde(default)]
    pub depends_on: Vec<usize>,
    /// Current status of this step.
    #[serde(default)]
    pub status: StepStatus,
    /// Result text after execution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub result: Option<String>,
    /// Risk level of this step, if known.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub risk_level: Option<RiskLevel>,
    /// Whether this step needs explicit user approval before execution.
    #[serde(default)]
    pub requires_approval: bool,
}

impl Default for PlanStep {
    fn default() -> Self {
        Self {
            index: 0,
            description: String::new(),
            tool: None,
            tool_args: None,
            depends_on: Vec::new(),
            status: StepStatus::Pending,
            result: None,
            risk_level: None,
            requires_approval: false,
        }
    }
}

/// An alternative approach the LLM considered but did not choose.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlanAlternative {
    pub name: String,
    pub description: String,
    #[serde(default)]
    pub reason_not_chosen: String,
    #[serde(default)]
    pub estimated_steps: usize,
}

/// A structured multi-step execution plan.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionPlan {
    /// Unique identifier for this plan.
    pub id: Uuid,
    /// The user's original goal/task.
    pub goal: String,
    /// Brief summary of the plan approach.
    pub summary: String,
    /// Ordered list of steps.
    pub steps: Vec<PlanStep>,
    /// Alternative approaches considered.
    #[serde(default)]
    pub alternatives: Vec<PlanAlternative>,
    /// Questions the LLM wants to ask the user for clarification.
    #[serde(default)]
    pub clarifications: Vec<String>,
    /// Overall plan status.
    pub status: PlanStatus,
    /// When the plan was created.
    pub created_at: DateTime<Utc>,
    /// When the plan was last updated.
    pub updated_at: DateTime<Utc>,
    /// Index of the step currently executing (if any).
    #[serde(default)]
    pub current_step: Option<usize>,
    /// Estimated LLM cost for executing this plan (USD).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub estimated_cost: Option<f64>,
    /// Whether this plan was generated via the LLM council.
    #[serde(default)]
    pub council_generated: bool,
}

impl ExecutionPlan {
    /// Create a new plan for a given goal.
    pub fn new(goal: impl Into<String>, summary: impl Into<String>) -> Self {
        let now = Utc::now();
        Self {
            id: Uuid::new_v4(),
            goal: goal.into(),
            summary: summary.into(),
            steps: Vec::new(),
            alternatives: Vec::new(),
            clarifications: Vec::new(),
            status: PlanStatus::Generating,
            created_at: now,
            updated_at: now,
            current_step: None,
            estimated_cost: None,
            council_generated: false,
        }
    }

    /// Find the next step that is pending and has all dependencies met.
    pub fn next_pending_step(&self) -> Option<usize> {
        for step in &self.steps {
            if step.status == StepStatus::Pending && self.dependencies_met(step.index) {
                return Some(step.index);
            }
        }
        None
    }

    /// Check whether all dependencies for a given step are satisfied.
    pub fn dependencies_met(&self, step_index: usize) -> bool {
        if let Some(step) = self.steps.get(step_index) {
            step.depends_on.iter().all(|&dep| {
                self.steps
                    .get(dep)
                    .map(|s| s.status == StepStatus::Completed)
                    .unwrap_or(false)
            })
        } else {
            false
        }
    }

    /// Mark a step as completed with its result.
    pub fn complete_step(&mut self, step_index: usize, result: impl Into<String>) {
        if let Some(step) = self.steps.get_mut(step_index) {
            step.status = StepStatus::Completed;
            step.result = Some(result.into());
            self.updated_at = Utc::now();
        }
    }

    /// Mark a step as failed with an error message.
    pub fn fail_step(&mut self, step_index: usize, error: impl Into<String>) {
        if let Some(step) = self.steps.get_mut(step_index) {
            step.status = StepStatus::Failed;
            step.result = Some(error.into());
            self.updated_at = Utc::now();
        }
    }

    /// Return a human-readable progress summary (e.g., "3/5 steps completed").
    pub fn progress_summary(&self) -> String {
        let completed = self
            .steps
            .iter()
            .filter(|s| s.status == StepStatus::Completed)
            .count();
        let failed = self
            .steps
            .iter()
            .filter(|s| s.status == StepStatus::Failed)
            .count();
        let total = self.steps.len();

        if failed > 0 {
            format!(
                "{}/{} steps completed ({} failed) — {}",
                completed, total, failed, self.status
            )
        } else {
            format!("{}/{} steps completed — {}", completed, total, self.status)
        }
    }
}

impl std::fmt::Display for ExecutionPlan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "Plan: {}", self.goal)?;
        writeln!(f, "Summary: {}", self.summary)?;
        writeln!(f, "Status: {}", self.status)?;
        writeln!(f)?;

        for step in &self.steps {
            let icon = match step.status {
                StepStatus::Pending => "○",
                StepStatus::InProgress => "●",
                StepStatus::Completed => "✓",
                StepStatus::Failed => "✗",
                StepStatus::Skipped => "⊘",
            };

            let tool_info = step
                .tool
                .as_deref()
                .map(|t| format!(" [{}]", t))
                .unwrap_or_default();

            let risk_badge = step
                .risk_level
                .as_ref()
                .map(|r| format!(" ({})", r))
                .unwrap_or_default();

            let approval = if step.requires_approval {
                " ⚠ approval"
            } else {
                ""
            };

            writeln!(
                f,
                "  {} {}. {}{}{}{}",
                icon,
                step.index + 1,
                step.description,
                tool_info,
                risk_badge,
                approval
            )?;
        }

        if !self.alternatives.is_empty() {
            writeln!(f)?;
            writeln!(f, "Alternatives considered:")?;
            for alt in &self.alternatives {
                writeln!(f, "  - {} ({})", alt.name, alt.reason_not_chosen)?;
            }
        }

        if let Some(cost) = self.estimated_cost {
            writeln!(f)?;
            writeln!(f, "Estimated cost: ${:.4}", cost)?;
        }

        Ok(())
    }
}

/// User decision on a plan under review.
#[derive(Debug, Clone)]
pub enum PlanDecision {
    /// Approve the plan and start execution.
    Approve,
    /// Reject the plan entirely.
    Reject,
    /// Edit a specific step's description.
    EditStep(usize, String),
    /// Remove a step by index.
    RemoveStep(usize),
    /// Add a new step at the given index with the given description.
    AddStep(usize, String),
    /// Reorder steps (new index ordering).
    ReorderSteps(Vec<usize>),
    /// Ask a question about the plan.
    AskQuestion(String),
}

/// System prompt addendum that instructs the LLM to output structured JSON plans.
pub const PLAN_GENERATION_PROMPT: &str = r#"You are generating a structured execution plan. Respond ONLY with valid JSON (no markdown fences, no extra text).

The JSON must have this structure:
{
  "summary": "Brief 1-2 sentence summary of the approach",
  "steps": [
    {
      "description": "Human-readable description of what this step does",
      "tool": "tool_name or null if no specific tool",
      "tool_args": { ... } or null if tool arguments should be determined at execution time,
      "depends_on": [0, 1] (indices of prerequisite steps, empty array if none),
      "risk_level": "read_only" | "write" | "execute" | "network" | "destructive" | null,
      "requires_approval": false
    }
  ],
  "alternatives": [
    {
      "name": "Alternative approach name",
      "description": "What it would do differently",
      "reason_not_chosen": "Why the chosen approach is better",
      "estimated_steps": 5
    }
  ],
  "clarifications": ["Question for the user if anything is unclear"],
  "estimated_cost": 0.05
}

Guidelines:
- Keep plans concise: prefer fewer, well-described steps over many granular ones
- Maximum 20 steps
- Set requires_approval=true for destructive or irreversible operations
- Include tool_args only when you are confident about the values
- Use depends_on to express execution order dependencies
- List alternatives only when meaningfully different approaches exist
- Include clarifications only for genuinely ambiguous requirements
"#;

/// Parse LLM-generated plan JSON into an `ExecutionPlan`.
///
/// Handles common LLM output quirks:
/// - Strips markdown code fences (```json ... ```)
/// - Handles trailing commas (via a lenient approach)
/// - Falls back to a single-step plan if parsing fails entirely
pub fn parse_plan_json(text: &str, goal: &str) -> ExecutionPlan {
    // Strip markdown code fences if present
    let cleaned = strip_code_fences(text);

    // Try parsing as JSON
    match serde_json::from_str::<serde_json::Value>(&cleaned) {
        Ok(value) => build_plan_from_json(value, goal),
        Err(_) => {
            // Try stripping trailing commas (common LLM mistake)
            let fixed = strip_trailing_commas(&cleaned);
            match serde_json::from_str::<serde_json::Value>(&fixed) {
                Ok(value) => build_plan_from_json(value, goal),
                Err(_) => fallback_single_step_plan(goal, text),
            }
        }
    }
}

/// Strip markdown code fences from LLM output.
fn strip_code_fences(text: &str) -> String {
    let trimmed = text.trim();
    if let Some(rest) = trimmed.strip_prefix("```json")
        && let Some(inner) = rest.strip_suffix("```")
    {
        return inner.trim().to_string();
    }
    if let Some(rest) = trimmed.strip_prefix("```")
        && let Some(inner) = rest.strip_suffix("```")
    {
        return inner.trim().to_string();
    }
    trimmed.to_string()
}

/// Remove trailing commas before } or ] (common LLM JSON mistake).
fn strip_trailing_commas(text: &str) -> String {
    let mut result = String::with_capacity(text.len());
    let chars: Vec<char> = text.chars().collect();
    let len = chars.len();

    let mut i = 0;
    while i < len {
        if chars[i] == ',' {
            // Look ahead past whitespace for } or ]
            let mut j = i + 1;
            while j < len && chars[j].is_whitespace() {
                j += 1;
            }
            if j < len && (chars[j] == '}' || chars[j] == ']') {
                // Skip the comma
                i += 1;
                continue;
            }
        }
        result.push(chars[i]);
        i += 1;
    }
    result
}

/// Build an ExecutionPlan from parsed JSON.
fn build_plan_from_json(value: serde_json::Value, goal: &str) -> ExecutionPlan {
    let summary = value["summary"]
        .as_str()
        .unwrap_or("Plan generated by LLM")
        .to_string();

    let mut steps = Vec::new();
    if let Some(step_arr) = value["steps"].as_array() {
        for (i, step_val) in step_arr.iter().enumerate() {
            let desc = step_val["description"]
                .as_str()
                .unwrap_or("(no description)")
                .to_string();

            let tool = step_val["tool"].as_str().map(|s| s.to_string());

            let tool_args = if step_val["tool_args"].is_null() {
                None
            } else {
                Some(step_val["tool_args"].clone())
            };

            let depends_on = step_val["depends_on"]
                .as_array()
                .map(|arr| {
                    arr.iter()
                        .filter_map(|v| v.as_u64().map(|n| n as usize))
                        .collect()
                })
                .unwrap_or_default();

            let risk_level = step_val["risk_level"].as_str().and_then(parse_risk_level);

            let requires_approval = step_val["requires_approval"].as_bool().unwrap_or(false);

            steps.push(PlanStep {
                index: i,
                description: desc,
                tool,
                tool_args,
                depends_on,
                status: StepStatus::Pending,
                result: None,
                risk_level,
                requires_approval,
            });
        }
    }

    let mut alternatives = Vec::new();
    if let Some(alt_arr) = value["alternatives"].as_array() {
        for alt_val in alt_arr {
            alternatives.push(PlanAlternative {
                name: alt_val["name"]
                    .as_str()
                    .unwrap_or("Alternative")
                    .to_string(),
                description: alt_val["description"].as_str().unwrap_or("").to_string(),
                reason_not_chosen: alt_val["reason_not_chosen"]
                    .as_str()
                    .unwrap_or("")
                    .to_string(),
                estimated_steps: alt_val["estimated_steps"].as_u64().unwrap_or(0) as usize,
            });
        }
    }

    let clarifications = value["clarifications"]
        .as_array()
        .map(|arr| {
            arr.iter()
                .filter_map(|v| v.as_str().map(|s| s.to_string()))
                .collect()
        })
        .unwrap_or_default();

    let estimated_cost = value["estimated_cost"].as_f64();

    let now = Utc::now();
    ExecutionPlan {
        id: Uuid::new_v4(),
        goal: goal.to_string(),
        summary,
        steps,
        alternatives,
        clarifications,
        status: PlanStatus::PendingReview,
        created_at: now,
        updated_at: now,
        current_step: None,
        estimated_cost,
        council_generated: false,
    }
}

/// Parse a risk level string from JSON.
fn parse_risk_level(s: &str) -> Option<RiskLevel> {
    match s {
        "read_only" => Some(RiskLevel::ReadOnly),
        "write" => Some(RiskLevel::Write),
        "execute" => Some(RiskLevel::Execute),
        "network" => Some(RiskLevel::Network),
        "destructive" => Some(RiskLevel::Destructive),
        _ => None,
    }
}

/// Create a fallback single-step plan when JSON parsing fails.
fn fallback_single_step_plan(goal: &str, raw_text: &str) -> ExecutionPlan {
    let now = Utc::now();
    let description = if raw_text.len() > 200 {
        format!("Execute task as described: {}...", &raw_text[..200])
    } else {
        format!("Execute task as described: {}", raw_text)
    };

    ExecutionPlan {
        id: Uuid::new_v4(),
        goal: goal.to_string(),
        summary: "Single-step execution (plan parsing failed, using fallback)".to_string(),
        steps: vec![PlanStep {
            index: 0,
            description,
            tool: None,
            tool_args: None,
            depends_on: Vec::new(),
            status: StepStatus::Pending,
            result: None,
            risk_level: None,
            requires_approval: false,
        }],
        alternatives: Vec::new(),
        clarifications: Vec::new(),
        status: PlanStatus::PendingReview,
        created_at: now,
        updated_at: now,
        current_step: None,
        estimated_cost: None,
        council_generated: false,
    }
}

/// Plan mode configuration.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlanConfig {
    /// Whether plan mode is enabled by default.
    pub enabled: bool,
    /// Whether to use the LLM council for plan generation.
    pub use_council: bool,
    /// Maximum number of steps in a plan.
    pub max_steps: usize,
    /// Whether to auto-approve read-only steps.
    pub auto_approve_readonly: bool,
}

impl Default for PlanConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            use_council: false,
            max_steps: 20,
            auto_approve_readonly: false,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_plan_status_display() {
        assert_eq!(PlanStatus::Generating.to_string(), "generating");
        assert_eq!(PlanStatus::PendingReview.to_string(), "pending review");
        assert_eq!(PlanStatus::Executing.to_string(), "executing");
        assert_eq!(PlanStatus::Completed.to_string(), "completed");
        assert_eq!(PlanStatus::Failed.to_string(), "failed");
        assert_eq!(PlanStatus::Cancelled.to_string(), "cancelled");
    }

    #[test]
    fn test_step_status_default() {
        assert_eq!(StepStatus::default(), StepStatus::Pending);
    }

    #[test]
    fn test_plan_step_default() {
        let step = PlanStep::default();
        assert_eq!(step.index, 0);
        assert!(step.description.is_empty());
        assert!(step.tool.is_none());
        assert!(step.tool_args.is_none());
        assert!(step.depends_on.is_empty());
        assert_eq!(step.status, StepStatus::Pending);
        assert!(step.result.is_none());
        assert!(!step.requires_approval);
    }

    #[test]
    fn test_execution_plan_new() {
        let plan = ExecutionPlan::new("Refactor auth module", "Split into separate files");
        assert_eq!(plan.goal, "Refactor auth module");
        assert_eq!(plan.summary, "Split into separate files");
        assert_eq!(plan.status, PlanStatus::Generating);
        assert!(plan.steps.is_empty());
        assert!(plan.current_step.is_none());
    }

    #[test]
    fn test_next_pending_step() {
        let mut plan = ExecutionPlan::new("test", "test");
        plan.steps = vec![
            PlanStep {
                index: 0,
                description: "Step 0".into(),
                status: StepStatus::Completed,
                ..Default::default()
            },
            PlanStep {
                index: 1,
                description: "Step 1".into(),
                depends_on: vec![0],
                ..Default::default()
            },
            PlanStep {
                index: 2,
                description: "Step 2".into(),
                depends_on: vec![1],
                ..Default::default()
            },
        ];

        // Step 0 is completed, step 1 depends on 0 (met), step 2 depends on 1 (not met)
        assert_eq!(plan.next_pending_step(), Some(1));
    }

    #[test]
    fn test_next_pending_step_no_deps() {
        let mut plan = ExecutionPlan::new("test", "test");
        plan.steps = vec![
            PlanStep {
                index: 0,
                description: "Step 0".into(),
                ..Default::default()
            },
            PlanStep {
                index: 1,
                description: "Step 1".into(),
                ..Default::default()
            },
        ];

        assert_eq!(plan.next_pending_step(), Some(0));
    }

    #[test]
    fn test_next_pending_step_all_completed() {
        let mut plan = ExecutionPlan::new("test", "test");
        plan.steps = vec![PlanStep {
            index: 0,
            description: "Step 0".into(),
            status: StepStatus::Completed,
            ..Default::default()
        }];

        assert_eq!(plan.next_pending_step(), None);
    }

    #[test]
    fn test_dependencies_met() {
        let mut plan = ExecutionPlan::new("test", "test");
        plan.steps = vec![
            PlanStep {
                index: 0,
                status: StepStatus::Completed,
                ..Default::default()
            },
            PlanStep {
                index: 1,
                depends_on: vec![0],
                ..Default::default()
            },
            PlanStep {
                index: 2,
                depends_on: vec![0, 1],
                ..Default::default()
            },
        ];

        assert!(plan.dependencies_met(0)); // no deps
        assert!(plan.dependencies_met(1)); // dep 0 is completed
        assert!(!plan.dependencies_met(2)); // dep 1 is still pending
    }

    #[test]
    fn test_complete_step() {
        let mut plan = ExecutionPlan::new("test", "test");
        plan.steps = vec![PlanStep {
            index: 0,
            description: "Read file".into(),
            ..Default::default()
        }];

        plan.complete_step(0, "File contents: hello world");
        assert_eq!(plan.steps[0].status, StepStatus::Completed);
        assert_eq!(
            plan.steps[0].result.as_deref(),
            Some("File contents: hello world")
        );
    }

    #[test]
    fn test_fail_step() {
        let mut plan = ExecutionPlan::new("test", "test");
        plan.steps = vec![PlanStep {
            index: 0,
            description: "Write file".into(),
            ..Default::default()
        }];

        plan.fail_step(0, "Permission denied");
        assert_eq!(plan.steps[0].status, StepStatus::Failed);
        assert_eq!(plan.steps[0].result.as_deref(), Some("Permission denied"));
    }

    #[test]
    fn test_progress_summary() {
        let mut plan = ExecutionPlan::new("test", "test");
        plan.status = PlanStatus::Executing;
        plan.steps = vec![
            PlanStep {
                index: 0,
                status: StepStatus::Completed,
                ..Default::default()
            },
            PlanStep {
                index: 1,
                status: StepStatus::Completed,
                ..Default::default()
            },
            PlanStep {
                index: 2,
                status: StepStatus::Failed,
                ..Default::default()
            },
            PlanStep {
                index: 3,
                ..Default::default()
            },
        ];

        let summary = plan.progress_summary();
        assert!(summary.contains("2/4"));
        assert!(summary.contains("1 failed"));
    }

    #[test]
    fn test_progress_summary_no_failures() {
        let mut plan = ExecutionPlan::new("test", "test");
        plan.status = PlanStatus::Executing;
        plan.steps = vec![
            PlanStep {
                index: 0,
                status: StepStatus::Completed,
                ..Default::default()
            },
            PlanStep {
                index: 1,
                ..Default::default()
            },
        ];

        let summary = plan.progress_summary();
        assert!(summary.contains("1/2"));
        assert!(!summary.contains("failed"));
    }

    #[test]
    fn test_parse_plan_json_valid() {
        let json = r#"{
            "summary": "Read and analyze a file",
            "steps": [
                {
                    "description": "Read the source file",
                    "tool": "file_read",
                    "tool_args": {"path": "src/main.rs"},
                    "depends_on": [],
                    "risk_level": "read_only",
                    "requires_approval": false
                },
                {
                    "description": "Analyze the code structure",
                    "tool": null,
                    "tool_args": null,
                    "depends_on": [0],
                    "risk_level": null,
                    "requires_approval": false
                }
            ],
            "alternatives": [
                {
                    "name": "Use codebase_search",
                    "description": "Search for patterns instead of reading the whole file",
                    "reason_not_chosen": "Direct file read is more thorough",
                    "estimated_steps": 3
                }
            ],
            "clarifications": [],
            "estimated_cost": 0.02
        }"#;

        let plan = parse_plan_json(json, "Analyze main.rs");
        assert_eq!(plan.goal, "Analyze main.rs");
        assert_eq!(plan.summary, "Read and analyze a file");
        assert_eq!(plan.steps.len(), 2);
        assert_eq!(plan.steps[0].tool.as_deref(), Some("file_read"));
        assert_eq!(plan.steps[0].risk_level, Some(RiskLevel::ReadOnly));
        assert_eq!(plan.steps[1].depends_on, vec![0]);
        assert!(plan.steps[1].tool.is_none());
        assert_eq!(plan.alternatives.len(), 1);
        assert_eq!(plan.estimated_cost, Some(0.02));
        assert_eq!(plan.status, PlanStatus::PendingReview);
    }

    #[test]
    fn test_parse_plan_json_with_code_fences() {
        let json = r#"```json
{
    "summary": "Simple plan",
    "steps": [
        {
            "description": "Do something",
            "tool": null,
            "tool_args": null,
            "depends_on": [],
            "risk_level": null,
            "requires_approval": false
        }
    ],
    "alternatives": [],
    "clarifications": []
}
```"#;

        let plan = parse_plan_json(json, "Test task");
        assert_eq!(plan.summary, "Simple plan");
        assert_eq!(plan.steps.len(), 1);
    }

    #[test]
    fn test_parse_plan_json_with_trailing_commas() {
        let json = r#"{
            "summary": "Plan with trailing commas",
            "steps": [
                {
                    "description": "Step one",
                    "tool": null,
                    "tool_args": null,
                    "depends_on": [],
                    "risk_level": null,
                    "requires_approval": false,
                },
            ],
            "alternatives": [],
            "clarifications": [],
        }"#;

        let plan = parse_plan_json(json, "Test");
        assert_eq!(plan.steps.len(), 1);
        assert_eq!(plan.steps[0].description, "Step one");
    }

    #[test]
    fn test_parse_plan_json_invalid_fallback() {
        let text = "This is not JSON at all, it's just a description of what to do.";
        let plan = parse_plan_json(text, "Do something");
        assert_eq!(plan.goal, "Do something");
        assert_eq!(plan.steps.len(), 1);
        assert!(plan.summary.contains("fallback"));
        assert!(
            plan.steps[0]
                .description
                .contains("Execute task as described")
        );
    }

    #[test]
    fn test_serialization_roundtrip() {
        let mut plan = ExecutionPlan::new("Test goal", "Test summary");
        plan.steps = vec![
            PlanStep {
                index: 0,
                description: "Step 0".into(),
                tool: Some("file_read".into()),
                risk_level: Some(RiskLevel::ReadOnly),
                ..Default::default()
            },
            PlanStep {
                index: 1,
                description: "Step 1".into(),
                depends_on: vec![0],
                requires_approval: true,
                ..Default::default()
            },
        ];
        plan.status = PlanStatus::PendingReview;

        let json = serde_json::to_string(&plan).unwrap();
        let deserialized: ExecutionPlan = serde_json::from_str(&json).unwrap();

        assert_eq!(deserialized.goal, "Test goal");
        assert_eq!(deserialized.steps.len(), 2);
        assert_eq!(deserialized.steps[0].tool.as_deref(), Some("file_read"));
        assert_eq!(deserialized.steps[1].depends_on, vec![0]);
        assert!(deserialized.steps[1].requires_approval);
    }

    #[test]
    fn test_plan_display() {
        let mut plan = ExecutionPlan::new("Refactor auth", "Split into modules");
        plan.status = PlanStatus::Executing;
        plan.steps = vec![
            PlanStep {
                index: 0,
                description: "Read auth.rs".into(),
                tool: Some("file_read".into()),
                status: StepStatus::Completed,
                risk_level: Some(RiskLevel::ReadOnly),
                ..Default::default()
            },
            PlanStep {
                index: 1,
                description: "Create auth/mod.rs".into(),
                tool: Some("file_write".into()),
                status: StepStatus::InProgress,
                risk_level: Some(RiskLevel::Write),
                requires_approval: true,
                ..Default::default()
            },
            PlanStep {
                index: 2,
                description: "Update imports".into(),
                status: StepStatus::Pending,
                ..Default::default()
            },
        ];

        let display = format!("{}", plan);
        assert!(display.contains("Refactor auth"));
        assert!(display.contains("Split into modules"));
        assert!(display.contains("✓")); // completed
        assert!(display.contains("●")); // in progress
        assert!(display.contains("○")); // pending
        assert!(display.contains("[file_read]"));
        assert!(display.contains("approval"));
    }

    #[test]
    fn test_plan_config_defaults() {
        let config = PlanConfig::default();
        assert!(!config.enabled);
        assert!(!config.use_council);
        assert_eq!(config.max_steps, 20);
        assert!(!config.auto_approve_readonly);
    }

    #[test]
    fn test_plan_config_serialization() {
        let config = PlanConfig {
            enabled: true,
            use_council: true,
            max_steps: 10,
            auto_approve_readonly: true,
        };
        let json = serde_json::to_string(&config).unwrap();
        let deserialized: PlanConfig = serde_json::from_str(&json).unwrap();
        assert!(deserialized.enabled);
        assert!(deserialized.use_council);
        assert_eq!(deserialized.max_steps, 10);
        assert!(deserialized.auto_approve_readonly);
    }

    #[test]
    fn test_strip_code_fences() {
        assert_eq!(strip_code_fences("```json\n{\"a\":1}\n```"), "{\"a\":1}");
        assert_eq!(strip_code_fences("```\n{\"a\":1}\n```"), "{\"a\":1}");
        assert_eq!(strip_code_fences("{\"a\":1}"), "{\"a\":1}");
    }

    #[test]
    fn test_strip_trailing_commas() {
        assert_eq!(strip_trailing_commas("{\"a\":1,}"), "{\"a\":1}");
        assert_eq!(strip_trailing_commas("[1,2,]"), "[1,2]");
        assert_eq!(strip_trailing_commas("{\"a\":[1,],}"), "{\"a\":[1]}");
        // Normal JSON should pass through unchanged
        assert_eq!(
            strip_trailing_commas("{\"a\":1,\"b\":2}"),
            "{\"a\":1,\"b\":2}"
        );
    }

    #[test]
    fn test_parse_plan_json_minimal() {
        // LLM might return minimal JSON
        let json = r#"{"summary": "Do it", "steps": []}"#;
        let plan = parse_plan_json(json, "Goal");
        assert_eq!(plan.summary, "Do it");
        assert!(plan.steps.is_empty());
    }

    #[test]
    fn test_complete_step_out_of_bounds() {
        let mut plan = ExecutionPlan::new("test", "test");
        plan.steps = vec![PlanStep {
            index: 0,
            ..Default::default()
        }];
        // Should not panic
        plan.complete_step(99, "result");
        assert_eq!(plan.steps[0].status, StepStatus::Pending);
    }

    #[test]
    fn test_dependencies_met_out_of_bounds() {
        let plan = ExecutionPlan::new("test", "test");
        assert!(!plan.dependencies_met(99));
    }
}
