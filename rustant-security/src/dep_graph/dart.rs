//! Dart pubspec.lock parser.

use super::{DepNode, DependencyGraph};
use crate::error::DepGraphError;

/// Parse a pubspec.lock file and populate the dependency graph.
///
/// pubspec.lock is generated by the Dart/Flutter `pub` package manager. It uses
/// YAML format, but we parse it line-by-line to avoid adding a YAML crate
/// dependency.
///
/// Dependency types:
/// - "direct main" → is_direct=true, is_dev=false
/// - "direct dev" → is_direct=true, is_dev=true
/// - "direct overridden" → is_direct=true, is_dev=false
/// - "transitive" → is_direct=false, is_dev=false
pub fn parse_pubspec_lock(content: &str, graph: &mut DependencyGraph) -> Result<(), DepGraphError> {
    let mut in_packages = false;
    let mut current_package: Option<String> = None;
    let mut current_version: Option<String> = None;
    let mut current_dependency: Option<String> = None;
    let mut current_source: Option<String> = None;
    let mut current_url: Option<String> = None;

    for line in content.lines() {
        let trimmed = line.trim();

        // Top-level "packages:" key
        if trimmed == "packages:" {
            in_packages = true;
            continue;
        }

        // Another top-level key (e.g., "sdks:")
        if !line.starts_with(' ') && !line.starts_with('\t') && !trimmed.is_empty() {
            if in_packages {
                // Flush the last package before leaving the packages section
                flush_package(
                    graph,
                    &current_package,
                    &current_version,
                    &current_dependency,
                    &current_source,
                    &current_url,
                );
                current_package = None;
                current_version = None;
                current_dependency = None;
                current_source = None;
                current_url = None;
            }
            if trimmed != "packages:" {
                in_packages = false;
            }
            continue;
        }

        if !in_packages {
            continue;
        }

        // Determine indentation level (number of leading spaces)
        let indent = line.len() - line.trim_start().len();

        // Package name at indent level 2 (e.g., "  flutter:")
        if indent == 2 && trimmed.ends_with(':') && !trimmed.contains('"') {
            // Flush previous package
            flush_package(
                graph,
                &current_package,
                &current_version,
                &current_dependency,
                &current_source,
                &current_url,
            );

            current_package = Some(trimmed.trim_end_matches(':').to_string());
            current_version = None;
            current_dependency = None;
            current_source = None;
            current_url = None;
            continue;
        }

        // Properties at indent level 4 (e.g., "    dependency: \"direct main\"")
        if indent == 4 && current_package.is_some() {
            if let Some(value) = trimmed.strip_prefix("dependency:") {
                current_dependency = Some(strip_yaml_quotes(value.trim()));
            } else if let Some(value) = trimmed.strip_prefix("version:") {
                current_version = Some(strip_yaml_quotes(value.trim()));
            } else if let Some(value) = trimmed.strip_prefix("source:") {
                current_source = Some(strip_yaml_quotes(value.trim()));
            }
            continue;
        }

        // Nested description properties at indent level 6
        if indent == 6
            && current_package.is_some()
            && let Some(value) = trimmed.strip_prefix("url:")
        {
            current_url = Some(strip_yaml_quotes(value.trim()));
        }
    }

    // Flush final package
    flush_package(
        graph,
        &current_package,
        &current_version,
        &current_dependency,
        &current_source,
        &current_url,
    );

    Ok(())
}

/// Strip surrounding double quotes from a YAML value string.
fn strip_yaml_quotes(s: &str) -> String {
    s.trim_matches('"').to_string()
}

/// Emit a DepNode from the accumulated package fields.
fn flush_package(
    graph: &mut DependencyGraph,
    name: &Option<String>,
    version: &Option<String>,
    dependency: &Option<String>,
    source: &Option<String>,
    url: &Option<String>,
) {
    let Some(name) = name else { return };
    let version = version.as_deref().unwrap_or("0.0.0");

    let dep_type = dependency.as_deref().unwrap_or("");
    let is_direct = dep_type.starts_with("direct");
    let is_dev = dep_type == "direct dev";

    let source_url = match (source.as_deref(), url.as_deref()) {
        (Some("hosted"), Some(u)) => Some(u.to_string()),
        (Some(s), _) => Some(s.to_string()),
        _ => None,
    };

    graph.add_node(DepNode {
        name: name.clone(),
        version: version.to_string(),
        ecosystem: "pub".into(),
        is_direct,
        is_dev,
        license: None,
        source: source_url,
    });
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_pubspec_lock_basic() {
        let content = r#"# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  collection:
    dependency: transitive
    description:
      name: collection
      sha256: abc123
      url: "https://pub.dev"
    source: hosted
    version: "1.18.0"
  flutter:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  http:
    dependency: "direct main"
    description:
      name: http
      sha256: def456
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  lints:
    dependency: "direct dev"
    description:
      name: lints
      sha256: ghi789
      url: "https://pub.dev"
    source: hosted
    version: "3.0.0"
sdks:
  dart: ">=3.0.0 <4.0.0"
"#;

        let mut graph = DependencyGraph::new();
        parse_pubspec_lock(content, &mut graph).unwrap();

        assert_eq!(graph.package_count(), 4);

        // collection is transitive
        let collection = graph
            .get_node(graph.find_node("collection").unwrap())
            .unwrap();
        assert!(!collection.is_direct);
        assert!(!collection.is_dev);
        assert_eq!(collection.version, "1.18.0");
        assert_eq!(collection.ecosystem, "pub");
        assert_eq!(collection.source.as_deref(), Some("https://pub.dev"));

        // flutter is direct main
        let flutter = graph.get_node(graph.find_node("flutter").unwrap()).unwrap();
        assert!(flutter.is_direct);
        assert!(!flutter.is_dev);
        assert_eq!(flutter.version, "0.0.0");
        assert_eq!(flutter.source.as_deref(), Some("sdk"));

        // http is direct main
        let http = graph.get_node(graph.find_node("http").unwrap()).unwrap();
        assert!(http.is_direct);
        assert!(!http.is_dev);
        assert_eq!(http.version, "1.1.0");

        // lints is direct dev
        let lints = graph.get_node(graph.find_node("lints").unwrap()).unwrap();
        assert!(lints.is_direct);
        assert!(lints.is_dev);
    }

    #[test]
    fn test_parse_pubspec_lock_empty() {
        let content = "packages:\nsdks:\n  dart: \">=3.0.0\"\n";

        let mut graph = DependencyGraph::new();
        parse_pubspec_lock(content, &mut graph).unwrap();

        assert_eq!(graph.package_count(), 0);
    }

    #[test]
    fn test_parse_pubspec_lock_direct_overridden() {
        let content = r#"packages:
  path:
    dependency: "direct overridden"
    description:
      name: path
      url: "https://pub.dev"
    source: hosted
    version: "1.8.3"
"#;

        let mut graph = DependencyGraph::new();
        parse_pubspec_lock(content, &mut graph).unwrap();

        assert_eq!(graph.package_count(), 1);
        let path_pkg = graph.get_node(graph.find_node("path").unwrap()).unwrap();
        assert!(path_pkg.is_direct);
        assert!(!path_pkg.is_dev);
    }

    #[test]
    fn test_parse_pubspec_lock_no_packages_key() {
        let content = "sdks:\n  dart: \">=3.0.0\"\n";

        let mut graph = DependencyGraph::new();
        parse_pubspec_lock(content, &mut graph).unwrap();

        // No packages section found, graph should be empty
        assert_eq!(graph.package_count(), 0);
    }

    #[test]
    fn test_parse_pubspec_lock_multiple_transitive() {
        let content = r#"packages:
  async:
    dependency: transitive
    description:
      name: async
      url: "https://pub.dev"
    source: hosted
    version: "2.11.0"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  meta:
    dependency: transitive
    description:
      name: meta
      url: "https://pub.dev"
    source: hosted
    version: "1.11.0"
"#;

        let mut graph = DependencyGraph::new();
        parse_pubspec_lock(content, &mut graph).unwrap();

        assert_eq!(graph.package_count(), 3);

        let all_packages = graph.all_packages();
        for pkg in &all_packages {
            assert!(!pkg.is_direct, "all should be transitive");
            assert_eq!(pkg.ecosystem, "pub");
        }
    }
}
