//! Swift Package.resolved (v2) parser.

use super::{DepNode, DependencyGraph};
use crate::error::DepGraphError;

/// Parse a Package.resolved (v2 format) file and populate the dependency graph.
///
/// Package.resolved is generated by Swift Package Manager and contains pinned
/// dependency versions. The v2 format uses a flat `pins` array with identity,
/// kind, location, and state fields.
///
/// Note: Package.resolved does not distinguish between direct and transitive
/// dependencies, so all packages are marked as `is_direct = true`.
pub fn parse_package_resolved(
    content: &str,
    graph: &mut DependencyGraph,
) -> Result<(), DepGraphError> {
    let lock: serde_json::Value =
        serde_json::from_str(content).map_err(|e| DepGraphError::LockfileParse {
            file: "Package.resolved".into(),
            message: e.to_string(),
        })?;

    // Validate format version
    let version = lock.get("version").and_then(|v| v.as_u64()).unwrap_or(0);

    if version != 2 && version != 3 {
        // v1 uses a different structure ("object" â†’ "pins"), but we only support v2+
        return Err(DepGraphError::LockfileParse {
            file: "Package.resolved".into(),
            message: format!("Unsupported Package.resolved version {version}, expected 2 or 3"),
        });
    }

    let pins = lock.get("pins").and_then(|p| p.as_array()).ok_or_else(|| {
        DepGraphError::LockfileParse {
            file: "Package.resolved".into(),
            message: "No 'pins' array found".into(),
        }
    })?;

    // First pass: add all nodes
    let mut node_indices = Vec::new();

    for pin in pins {
        let identity = pin
            .get("identity")
            .and_then(|i| i.as_str())
            .unwrap_or("unknown")
            .to_string();

        let version_str = pin
            .get("state")
            .and_then(|s| s.get("version"))
            .and_then(|v| v.as_str())
            .unwrap_or("0.0.0")
            .to_string();

        let location = pin
            .get("location")
            .and_then(|l| l.as_str())
            .map(|s| s.to_string());

        let idx = graph.add_node(DepNode {
            name: identity,
            version: version_str,
            ecosystem: "swift".into(),
            is_direct: true,
            is_dev: false,
            license: None,
            source: location,
        });

        node_indices.push(idx);
    }

    // Package.resolved does not encode dependency relationships between pins,
    // so no edges are added. The graph captures the full resolved set of packages.

    // If there are multiple pins, we can infer a virtual root that depends on all of them.
    // However, without Package.swift context, we cannot determine the actual dependency tree.

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_package_resolved_v2() {
        let content = r#"{
  "pins": [
    {
      "identity": "swift-argument-parser",
      "kind": "remoteSourceControl",
      "location": "https://github.com/apple/swift-argument-parser",
      "state": {
        "revision": "fee6933f37fde9a5e12a1e4aeaa93fe60116ff2a",
        "version": "1.2.3"
      }
    },
    {
      "identity": "swift-log",
      "kind": "remoteSourceControl",
      "location": "https://github.com/apple/swift-log.git",
      "state": {
        "revision": "532d8b529501fb73a2166571e18a00bbf4b940b7",
        "version": "1.5.4"
      }
    },
    {
      "identity": "swift-nio",
      "kind": "remoteSourceControl",
      "location": "https://github.com/apple/swift-nio.git",
      "state": {
        "revision": "cf281631ff10ec6111f2761052aa81896bcff485",
        "version": "2.62.0"
      }
    }
  ],
  "version": 2
}"#;

        let mut graph = DependencyGraph::new();
        parse_package_resolved(content, &mut graph).unwrap();

        assert_eq!(graph.package_count(), 3);
        assert!(graph.find_node("swift-argument-parser").is_some());
        assert!(graph.find_node("swift-log").is_some());
        assert!(graph.find_node("swift-nio").is_some());

        // All should be marked direct
        let directs = graph.direct_deps();
        assert_eq!(directs.len(), 3);

        // Check ecosystem
        let node = graph
            .get_node(graph.find_node("swift-log").unwrap())
            .unwrap();
        assert_eq!(node.ecosystem, "swift");
        assert_eq!(node.version, "1.5.4");
        assert_eq!(
            node.source.as_deref(),
            Some("https://github.com/apple/swift-log.git")
        );
    }

    #[test]
    fn test_parse_package_resolved_empty_pins() {
        let content = r#"{"pins": [], "version": 2}"#;

        let mut graph = DependencyGraph::new();
        parse_package_resolved(content, &mut graph).unwrap();

        assert_eq!(graph.package_count(), 0);
    }

    #[test]
    fn test_parse_package_resolved_version_3() {
        let content = r#"{
  "pins": [
    {
      "identity": "vapor",
      "kind": "remoteSourceControl",
      "location": "https://github.com/vapor/vapor.git",
      "state": {
        "revision": "abc123",
        "version": "4.89.0"
      }
    }
  ],
  "version": 3
}"#;

        let mut graph = DependencyGraph::new();
        parse_package_resolved(content, &mut graph).unwrap();

        assert_eq!(graph.package_count(), 1);
        let node = graph.get_node(graph.find_node("vapor").unwrap()).unwrap();
        assert_eq!(node.version, "4.89.0");
    }

    #[test]
    fn test_parse_package_resolved_unsupported_version() {
        let content = r#"{"object": {"pins": []}, "version": 1}"#;

        let mut graph = DependencyGraph::new();
        let result = parse_package_resolved(content, &mut graph);
        assert!(result.is_err());

        let err = result.unwrap_err();
        assert!(err.to_string().contains("Unsupported"));
    }

    #[test]
    fn test_parse_package_resolved_missing_version() {
        let content = r#"{
  "pins": [
    {
      "identity": "no-version-pkg",
      "kind": "remoteSourceControl",
      "location": "https://github.com/example/pkg.git",
      "state": {
        "revision": "deadbeef"
      }
    }
  ],
  "version": 2
}"#;

        let mut graph = DependencyGraph::new();
        parse_package_resolved(content, &mut graph).unwrap();

        assert_eq!(graph.package_count(), 1);
        let node = graph
            .get_node(graph.find_node("no-version-pkg").unwrap())
            .unwrap();
        // Falls back to 0.0.0 when version is absent (branch pin)
        assert_eq!(node.version, "0.0.0");
    }

    #[test]
    fn test_parse_package_resolved_invalid_json() {
        let content = "not valid json at all";
        let mut graph = DependencyGraph::new();
        let result = parse_package_resolved(content, &mut graph);
        assert!(result.is_err());
    }
}
