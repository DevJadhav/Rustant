//! Elixir mix.lock parser.

use super::{DepEdge, DepNode, DependencyGraph};
use crate::error::DepGraphError;

/// Parse a mix.lock file and populate the dependency graph.
///
/// mix.lock is generated by the Elixir/Erlang `mix` build tool. It uses Elixir
/// map syntax with tuples. Each entry looks like:
///
/// ```elixir
/// %{
///   "jason": {:hex, :jason, "1.4.1", "hash", [:mix], [], "hexpm", "hash2"},
///   "plug": {:hex, :plug, "1.15.0", "hash", [:mix], [{:jason, "~> 1.0", ...}], "hexpm", "hash2"},
/// }
/// ```
///
/// We extract the package name and version from the {:hex, :name, "version", ...}
/// tuple pattern, and parse inline dependency references from the deps list.
pub fn parse_mix_lock(content: &str, graph: &mut DependencyGraph) -> Result<(), DepGraphError> {
    // Collect all parsed packages first so we can resolve edges
    let mut packages: Vec<(String, String, Vec<String>)> = Vec::new();

    for line in content.lines() {
        let trimmed = line.trim();

        // Skip map delimiters and empty lines
        if trimmed.is_empty() || trimmed == "%{" || trimmed == "}" || trimmed.starts_with('#') {
            continue;
        }

        // Match lines like:  "name": {:hex, :name, "version", ...}
        // Extract the quoted key first
        let Some(key_start) = trimmed.find('"') else {
            continue;
        };
        let after_key_start = &trimmed[key_start + 1..];
        let Some(key_end) = after_key_start.find('"') else {
            continue;
        };
        let package_name = after_key_start[..key_end].to_string();

        // Find the tuple content after {:hex,
        let Some(hex_pos) = trimmed.find("{:hex,") else {
            // Could be a non-hex source (e.g., :git), skip for now
            continue;
        };
        let tuple_content = &trimmed[hex_pos + 6..]; // after "{:hex,"

        // Extract version: the next quoted string after ":name,"
        // Pattern: :name, "version", ...
        // Skip the :name atom
        let Some(atom_pos) = tuple_content.find(':') else {
            continue;
        };
        let after_atom = &tuple_content[atom_pos + 1..];
        let Some(comma_pos) = after_atom.find(',') else {
            continue;
        };
        let after_comma = after_atom[comma_pos + 1..].trim();

        // Now extract the version string (first quoted string)
        let version = extract_quoted_string(after_comma).unwrap_or_else(|| "0.0.0".to_string());

        // Extract dependencies from the deps list
        // The deps are in the 6th element (0-indexed: 5th) of the tuple: [...deps...]
        let dep_names = extract_dep_names(trimmed);

        packages.push((package_name, version, dep_names));
    }

    // First pass: add all nodes
    let mut node_map = std::collections::HashMap::new();
    for (name, version, _) in &packages {
        let idx = graph.add_node(DepNode {
            name: name.clone(),
            version: version.clone(),
            ecosystem: "hex".into(),
            is_direct: false, // mix.lock doesn't distinguish; could cross-ref with mix.exs
            is_dev: false,
            license: None,
            source: Some("hexpm".into()),
        });
        node_map.insert(name.clone(), idx);
    }

    // Second pass: add edges from dependency references
    for (name, _, dep_names) in &packages {
        if let Some(&from_idx) = node_map.get(name) {
            for dep_name in dep_names {
                if let Some(&to_idx) = node_map.get(dep_name) {
                    graph.add_edge(
                        from_idx,
                        to_idx,
                        DepEdge {
                            version_req: None,
                            optional: false,
                        },
                    );
                }
            }
        }
    }

    Ok(())
}

/// Extract the first double-quoted string from a slice.
fn extract_quoted_string(s: &str) -> Option<String> {
    let start = s.find('"')?;
    let rest = &s[start + 1..];
    let end = rest.find('"')?;
    Some(rest[..end].to_string())
}

/// Extract dependency atom names from a mix.lock line's deps list.
///
/// The deps list in a mix.lock tuple looks like:
///   [{:jason, "~> 1.0", [hex: :jason, ...]}, {:plug_crypto, ...}]
///
/// We extract the atom names after `{:` within the square-bracketed list
/// that represents the dependencies (the 6th field in the hex tuple).
fn extract_dep_names(line: &str) -> Vec<String> {
    let mut deps = Vec::new();

    // Find the deps list â€” it's the content within square brackets
    // that contains `{:` tuples. mix.lock has two bracket groups:
    // the build tools list (e.g., [:mix]) and the deps list.
    // The deps list is the second [...] group after {:hex, ...

    let Some(hex_pos) = line.find("{:hex,") else {
        return deps;
    };
    let after_hex = &line[hex_pos..];

    // Find square bracket groups: first is build tools, second is deps
    let mut bracket_depth = 0;
    let mut bracket_groups: Vec<(usize, usize)> = Vec::new();
    let mut group_start = 0;

    for (i, ch) in after_hex.char_indices() {
        match ch {
            '[' => {
                if bracket_depth == 0 {
                    group_start = i;
                }
                bracket_depth += 1;
            }
            ']' => {
                bracket_depth -= 1;
                if bracket_depth == 0 {
                    bracket_groups.push((group_start, i));
                }
            }
            _ => {}
        }
    }

    // The second bracket group is the dependency list
    if bracket_groups.len() >= 2 {
        let (start, end) = bracket_groups[1];
        let deps_str = &after_hex[start + 1..end];

        // Extract atoms from {:name, patterns
        let mut search_from = 0;
        while let Some(pos) = deps_str[search_from..].find("{:") {
            let atom_start = search_from + pos + 2;
            // Find the end of the atom (comma or space or })
            let atom_end = deps_str[atom_start..]
                .find([',', ' ', '}'])
                .map(|p| atom_start + p)
                .unwrap_or(deps_str.len());
            let atom_name = &deps_str[atom_start..atom_end];
            if !atom_name.is_empty() {
                deps.push(atom_name.to_string());
            }
            search_from = atom_end;
        }
    }

    deps
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_mix_lock_basic() {
        let content = r#"%{
  "jason": {:hex, :jason, "1.4.1", "af1ceaf2ee0e5f1d6a2eb1e95e5e4ab8e0a0e885", [:mix], [], "hexpm", "fdf843bca858203ae1de16da2ee206f53416bbda5dc8c9e78f43243de4bc3afe"},
  "plug": {:hex, :plug, "1.15.3", "bc3a1650cbf9ff22a79c16759c8b13bb65bfe53fe7d5ff6cae1b73649eb5c7e4", [:mix], [{:mime, "~> 1.0 or ~> 2.0", [hex: :mime, repo: "hexpm", optional: false]}, {:plug_crypto, "~> 1.1.1 or ~> 1.2 or ~> 2.0", [hex: :plug_crypto, repo: "hexpm", optional: false]}], "hexpm", "cc2d0488f4818b2d77a1e0af90b90b1f1010a005a68b8e1e0df51f5aaa8ad34e"},
  "plug_crypto": {:hex, :plug_crypto, "2.0.0", "07eafb06a62a2350c2a030e12f8bcd48a1e0bdb0e8c8bd98f35d9c3e9a44a11e", [:mix], [], "hexpm", "5e8b29d94b70bd0d71f86a0ced6d856862f8e4c1a0a1b0e98c9a0e6dbb8f3d1a"},
  "mime": {:hex, :mime, "2.0.5", "dc34c8f0bff2affd404f8fdf44f8317cd5c28bf1a2033f1fbb1acef4e4e21c81", [:mix], [], "hexpm", "da0d64a365c45bc9935cc5c8a7f8f2aa8c2e8eb3e2a6e21d8e0b1e5b1a2d5a10"},
}"#;

        let mut graph = DependencyGraph::new();
        parse_mix_lock(content, &mut graph).unwrap();

        assert_eq!(graph.package_count(), 4);

        // Check all packages exist
        assert!(graph.find_node("jason").is_some());
        assert!(graph.find_node("plug").is_some());
        assert!(graph.find_node("plug_crypto").is_some());
        assert!(graph.find_node("mime").is_some());

        // Check versions
        let jason = graph.get_node(graph.find_node("jason").unwrap()).unwrap();
        assert_eq!(jason.version, "1.4.1");
        assert_eq!(jason.ecosystem, "hex");

        let plug = graph.get_node(graph.find_node("plug").unwrap()).unwrap();
        assert_eq!(plug.version, "1.15.3");

        // Check that plug depends on mime and plug_crypto
        let plug_deps = graph.transitive_deps("plug");
        let dep_names: Vec<&str> = plug_deps.iter().map(|d| d.name.as_str()).collect();
        assert!(dep_names.contains(&"mime"), "plug should depend on mime");
        assert!(
            dep_names.contains(&"plug_crypto"),
            "plug should depend on plug_crypto"
        );

        // jason has no deps
        let jason_deps = graph.transitive_deps("jason");
        assert_eq!(jason_deps.len(), 0);
    }

    #[test]
    fn test_parse_mix_lock_empty() {
        let content = "%{\n}\n";

        let mut graph = DependencyGraph::new();
        parse_mix_lock(content, &mut graph).unwrap();

        assert_eq!(graph.package_count(), 0);
    }

    #[test]
    fn test_parse_mix_lock_single_package() {
        let content = r#"%{
  "decimal": {:hex, :decimal, "2.1.1", "5611dca5d4b2c3dd497dec8f68751f1f1a54c7a818f5f2a4449606f0bbf4f0a8", [:mix], [], "hexpm", "53cfe5f497ed0e7771ae1a475575603d77425099ba5faef9394932b35020ffcc"},
}"#;

        let mut graph = DependencyGraph::new();
        parse_mix_lock(content, &mut graph).unwrap();

        assert_eq!(graph.package_count(), 1);
        let decimal = graph.get_node(graph.find_node("decimal").unwrap()).unwrap();
        assert_eq!(decimal.version, "2.1.1");
        assert_eq!(decimal.ecosystem, "hex");
        assert_eq!(decimal.source.as_deref(), Some("hexpm"));
    }

    #[test]
    fn test_extract_dep_names() {
        let line = r#"  "plug": {:hex, :plug, "1.15.3", "hash", [:mix], [{:mime, "~> 2.0", [hex: :mime]}, {:plug_crypto, "~> 2.0", [hex: :plug_crypto]}], "hexpm", "hash2"},"#;
        let deps = extract_dep_names(line);
        assert_eq!(deps, vec!["mime", "plug_crypto"]);
    }

    #[test]
    fn test_extract_dep_names_empty() {
        let line = r#"  "jason": {:hex, :jason, "1.4.1", "hash", [:mix], [], "hexpm", "hash2"},"#;
        let deps = extract_dep_names(line);
        assert!(deps.is_empty());
    }

    #[test]
    fn test_extract_quoted_string() {
        assert_eq!(
            extract_quoted_string(r#""1.4.1", rest"#),
            Some("1.4.1".to_string())
        );
        assert_eq!(extract_quoted_string("no quotes"), None);
        assert_eq!(
            extract_quoted_string(r#"  "hello"  "#),
            Some("hello".to_string())
        );
    }
}
