//! Vulnerability check tool â€” checks a specific package for known CVEs and advisories.

use async_trait::async_trait;
use rustant_core::error::ToolError;
use rustant_core::types::{RiskLevel, ToolOutput};
use rustant_tools::registry::Tool;
use serde_json::{Value, json};
use std::path::Path;
use std::time::Duration;

use crate::scanners::sca::ScaScanner;

/// Checks a specific package and version against vulnerability databases.
pub struct VulnerabilityCheckTool;

impl Default for VulnerabilityCheckTool {
    fn default() -> Self {
        Self
    }
}

impl VulnerabilityCheckTool {
    pub fn new() -> Self {
        Self
    }
}

#[async_trait]
impl Tool for VulnerabilityCheckTool {
    fn name(&self) -> &str {
        "vulnerability_check"
    }

    fn description(&self) -> &str {
        "Check a specific package for known vulnerabilities"
    }

    fn parameters_schema(&self) -> Value {
        json!({
            "type": "object",
            "properties": {
                "package": {
                    "type": "string",
                    "description": "Package name"
                },
                "version": {
                    "type": "string",
                    "description": "Package version"
                },
                "ecosystem": {
                    "type": "string",
                    "description": "Ecosystem (npm/pypi/crates/maven)"
                }
            },
            "required": ["package"]
        })
    }

    fn risk_level(&self) -> RiskLevel {
        RiskLevel::ReadOnly
    }

    fn timeout(&self) -> Duration {
        Duration::from_secs(30)
    }

    async fn execute(&self, args: Value) -> Result<ToolOutput, ToolError> {
        let package = match args.get("package").and_then(|v| v.as_str()) {
            Some(p) if !p.is_empty() => p,
            _ => {
                return Ok(ToolOutput::text(
                    "Required parameter 'package' is missing or empty.",
                ));
            }
        };

        let version = args
            .get("version")
            .and_then(|v| v.as_str())
            .unwrap_or("latest");

        let ecosystem = args
            .get("ecosystem")
            .and_then(|v| v.as_str())
            .unwrap_or("auto");

        let valid_ecosystems = ["npm", "pypi", "crates", "maven", "auto"];
        if !valid_ecosystems.contains(&ecosystem) {
            return Ok(ToolOutput::text(format!(
                "Unknown ecosystem '{ecosystem}'. Supported: npm, pypi, crates, maven"
            )));
        }

        // Use ScaScanner to check the package against the advisory database
        let scanner = ScaScanner::new();
        let lockfile_placeholder = Path::new("Cargo.lock");
        let findings = scanner.check_package(package, version, lockfile_placeholder);

        let mut output =
            format!("Vulnerability check for '{package}@{version}' (ecosystem: {ecosystem}).\n\n");

        if findings.is_empty() {
            output.push_str(
                "No known vulnerabilities found in the local advisory database.\n\n\
                 Note: The local advisory database may not contain all known CVEs. \
                 For comprehensive results, consider using:\n\
                 - OSV: https://osv.dev/\n\
                 - GitHub Advisory Database: https://github.com/advisories\n\
                 - NVD: https://nvd.nist.gov/\n\
                 - RustSec (for Rust): https://rustsec.org/advisories/",
            );
        } else {
            output.push_str(&format!(
                "Found {} known vulnerabilities:\n\n",
                findings.len()
            ));

            for (i, finding) in findings.iter().enumerate() {
                output.push_str(&format!(
                    "{}. [{}] {}\n",
                    i + 1,
                    finding.severity.as_str().to_uppercase(),
                    finding.title
                ));
                output.push_str(&format!("   {}\n", finding.description));

                if !finding.references.is_empty() {
                    let refs: Vec<String> = finding
                        .references
                        .iter()
                        .map(|r| {
                            if let Some(ref url) = r.url {
                                format!("{} ({})", r.id, url)
                            } else {
                                r.id.clone()
                            }
                        })
                        .collect();
                    output.push_str(&format!("   References: {}\n", refs.join(", ")));
                }

                if let Some(ref cvss) = finding.cvss_score {
                    output.push_str(&format!("   CVSS: {cvss:.1}\n"));
                }

                if let Some(ref rem) = finding.remediation {
                    output.push_str(&format!("   Fix: {}\n", rem.description));
                }
                output.push('\n');
            }
        }

        Ok(ToolOutput::text(output))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tool_name() {
        let tool = VulnerabilityCheckTool::new();
        assert_eq!(tool.name(), "vulnerability_check");
        assert_eq!(tool.risk_level(), RiskLevel::ReadOnly);
    }

    #[test]
    fn test_schema() {
        let tool = VulnerabilityCheckTool::new();
        let schema = tool.parameters_schema();
        assert_eq!(schema["type"], "object");
        assert!(schema["properties"]["package"].is_object());
        assert!(schema["properties"]["version"].is_object());
        assert!(schema["properties"]["ecosystem"].is_object());
        assert!(
            schema["required"]
                .as_array()
                .unwrap()
                .contains(&json!("package"))
        );
    }

    #[tokio::test]
    async fn test_execute_with_package() {
        let tool = VulnerabilityCheckTool::new();
        let result = tool
            .execute(json!({"package": "lodash", "version": "4.17.20", "ecosystem": "npm"}))
            .await
            .unwrap();
        assert!(result.content.contains("lodash@4.17.20"));
        assert!(result.content.contains("npm"));
    }

    #[tokio::test]
    async fn test_execute_missing_package() {
        let tool = VulnerabilityCheckTool::new();
        let result = tool.execute(json!({})).await.unwrap();
        assert!(result.content.contains("missing"));
    }

    #[tokio::test]
    async fn test_execute_invalid_ecosystem() {
        let tool = VulnerabilityCheckTool::new();
        let result = tool
            .execute(json!({"package": "test", "ecosystem": "invalid"}))
            .await
            .unwrap();
        assert!(result.content.contains("Unknown ecosystem"));
    }
}
